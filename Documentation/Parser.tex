\chapter{Parser}\label{chap:Parser}

\section{TypeChecker}
Der ParseTree wird der Methode \texttt{analyze()} übergeben, welche die Semantik überprüft. Ausgehend von dieser Startmethode wird der gesamte ParseTree durch rekursive Aufrufe überprüft. Die Implementierung setzt die Vorlage aus dem \emph{Systemnahes Programmieren II}-Skript um.

Der TypeChecker überprüft, ob ein geparster Baum die Syntaxregeln der Sprache einhält. Dazu werden die Inhalte der Teilbäume auf ihre Art, den Typ und die Reihenfolge überprüft. Dabei geht der TypeChecker wie ein Besucher von Teilbaum zu Teilbaum, bis der komplette Baum durchlaufen wurde.
Dabei wird je nach Regel eine andere Methode zum Parsen aufgerufen, die dann die Reihenfolge der Abarbeitung einhält und nach den Vorgaben aus dem Skript den Baum parst.

Die Methode \texttt{analyze()} bekommt einen Knoten übergeben. Dieser Node hat eine zugeordnete Regel. Anhand dieser wird eine der entsprechenden \texttt{analyze()} Methoden aufgerufen.

In diesen Methoden werden zunächst alle möglichen Teilbäume des Nodes übergeben, falls diese nicht vollständig sind wird der Node mit einem Nullwert initialisiert.
Die gegebenen Teilbäume ermöglichen es nun eindeutig die Semantik des ganzen Baumes zu überprüfen. Sollte die Überprüfung erfolgreich sein, es sind also keine Regelverstöße vorhanden, wird über die Methode \texttt{setType()} der Knotentyp gesetzt.

Sollte ein Teilbaum allerdings gegen die gegebene Grammatik verstoßen wird ein Fehler mit relevanten Informationen auf der Konsole ausgegeben. Anschließend wird der Knotentyp auf \texttt{ERROR\_TYPE} gesetzt.

\section{Code Generator}
Nachdem der TypeChecker die Grammatik überprüft hat, ist es möglich, dass ein Maschinencode aus dem ParseTree erzeugt wird. Diese Aufgabe übernimmt der Codegenerator und erstellt somit den Maschinencode. Aufgerufen wird der Codegenerator mit dem Aufruf \texttt{runCodeGenerator()}. Dabei geht der Codegenerator jeden Knoten durch und schreibt für jeden Blattknoten den richtigen Maschinencode. Dieser Maschinencode wird als String gespeichert und immer mehr erweitert. Um dies zu bewerkstelligen wird von dem ParseTree der Wurzelknoten abgefragt und an die Funktion \texttt{generateCodeProg()} weitergegeben. Damit beginnt auch die eigentliche Arbeit des Codegenerator. Am Ende wird der generierte Code in einem Datei umgewandelt.

\lstinputlisting[language=C++]{CodeGenerator1.cpp}

Unter der Funktion \texttt{generateCodeProg()} verzweigt sich der Wurzelknoten das erste Mal.  Laut Grammatik gibt es da den ersten Kindknoten \texttt{DECLS}, der alle Deklarationen von Identifier und Arrays beinhaltet., und den Zweiten \texttt{STATEMENTS}, der alle Aussagen des Programms beinhaltet. Diese beide Kindknoten werden dann mit der Funktion \texttt{generateCode()} nach den Regeln der Grammatik überprüft und an weitere Funktionen weitergegeben. Der erste Knoten hat den Regeltyp \texttt{DECLS} und wird an die Funktion \texttt{generateCodeDecls()} weitergeleitet. Jedoch kann er auch keine Deklarationen beinhalten und somit ist der  Regeltyp \texttt{DECLS\_EMPTY}. Das selbe gilt für den zweiten Knoten \texttt{STATEMENTS}.

\lstinputlisting[language=C++]{CodeGenerator2.cpp}

Wenn das Programm Deklarationen beinhaltet und die Funktion \texttt{generateCodeDecls()} aufgerufen wird, dann verzweigt sich der Knoten wieder in zwei Kindsknoten. Der erste Knoten enthält dann eine einzige Deklaration und der Zweite alle nachfolgende Deklarationen. Der erste Knoten ist dann ein Regeltyp \texttt{DECL} und geht wieder an die Funtkion \texttt{generateCode()}. Dort wird dann die Funktion \texttt{generateCodeDecl()} mit dem Knoten aufgerufen. Der zweite Knoten ist vom Regeltyp \texttt{DECLS} und ist dafür da, dass rekursiv alle Deklarationen über die Funktion \texttt{generateCodeDecls()} gelesen wird. Bis der Regeltyp irgendwann \texttt{DECL\_EMPTY} lautet und es keine weitere Deklarationen vorkommen. Diese Funktion alle Deklarationen zu lesen, wird auch \texttt{generateCodeStatemtents()} benutzt, um alle Aussagen nacheinander zu erkennen.

\lstinputlisting[language=C++]{CodeGenerator3.cpp}

Hat man eine einzige Deklaration mit \texttt{generateCodeDecl()} erkannt, dann muss man die Deklaration zwischen Array oder  Nicht-Array unterscheiden. Deswegen teilt sich auch dieser Knoten in zwei Kindsknoten auf. Einmal in den Knoten mit dem Inhalt, ob es ein Array ist oder nicht. Und in den zweiten Knoten mit dem Identifier, der immer da ist. Auch hier werden die Kindsknoten über die Funktion \texttt{generateCode()} zu der richtigen Funktion sortiert. Der erste Knoten kann entweder den Regeltyp des \texttt{ARRAY} oder \texttt{ARRAY\_EMPTY} haben. Wenn der Regeltyp \texttt{ARRAY\_EMPTY} lautet, dann ist die Deklaration eine einfache Variable. Aber bei dem Regeltyp \texttt{ARRAY} und dann wird die Funktion \texttt{generateCodeArray()} aufgerufen. Jedoch davor wird der zweite Knoten das Identifier gelesen und man erhält als Kind von \texttt{DECL} den Token von der Symboltabelle zurück. Dieser beinhaltet den Identifier und die erste Deklaration kann mit Maschinencode in die Ausgabedatei geschrieben werden. Der Maschinencode würde dann ''DS \$'' und das Lexem im Token sein, z.B. \emph{a}. Somit hat man eine einfache Integer Variable deklariert und der Code wird über \texttt{generateCodeArray()} zu einem Array erweitert oder wegen dem Regeltyp \texttt{ARRAY\_EMPTY} weggelassen. So ähnlich werden auch die Aussagen aufgelöste, dabei geht Verzweigung bis zum letzten Blattknoten und dann wird der Inhalt als Maschinencode in den Ausgabe gespeichert.

\lstinputlisting[language=C++]{CodeGenerator4.cpp}

In Abbildung~\ref{fig:codegenerator} sieht man ein Beispiel wie der Codegenerator einen Maschinencode erzeugt. Dabei geht er die blaue Knoten von dem ParseTree hinab bis er den Blattknoten erreicht. Die Baumstruktur geht man von links nach rechts durch, damit die Reihenfolge des Maschinencodes eingehalten wird. Also in unserem Beispiel würde man ganz links den grünen Token Identifier erreichen und damit dann den ersten Ausgabetext schreiben. Dieser lautet DS \$ a . Dabei ist a der Identifier. Nachfolgend geht man bis zur nächsten Abzweigung zurück und geht den anderen Weg. Dadurch kommt man auf den \texttt{ARRAY}-Knoten der eine 1 gespeichert hat und ausgibt. Dasselbe wird mit den \texttt{STATEMENTS}-Knoten gemacht. Jedoch  kommt man direkt auf  einen speziellen \texttt{STATEMENT}-Knoten. In diesem Beispiel wäre es der Knoten mit dem Regeltyp \texttt{STATEMENT\_IDENTIFIER}, um die Variable festzulegen. \texttt{STATEMENT\_IDENTIFIER} wird aus drei Kindsknoten berechnet. Der Erste führt zu einem Integer-Token. Mit dem der Maschinencode LC 4 direkt geschrieben werden kann. Der zweite Token ist mal wieder ein Token von der Symboltabelle mit einem Lexem, das dann ausgegeben wird. Und zum Schluss wird der Knoten Index, mit dem man das Array aufrufen kann.
\vspace{4cm}

\begin{figure}[!htb]
    \centering
      \includegraphics[width=1.0\linewidth]{Maschinencode.png}
    \caption{Maschinencode-Erzeugung durch CodeGenerator}\label{fig:codegenerator}
\end{figure}
